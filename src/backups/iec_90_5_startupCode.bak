/************************************************************************/
/* SISCO SOFTWARE MODULE HEADER *****************************************/
/************************************************************************/
/*	(c) Copyright Systems Integration Specialists Company, Inc.,	*/
/*	2011-2011, All Rights Reserved					*/
/*									*/
/* MODULE NAME : udp_pub.c						*/
/* PRODUCT(S)  : MMS-EASE Lite						*/
/*									*/
/* MODULE DESCRIPTION :							*/
/*	UDP Publisher sample application				*/
/*									*/
/* GLOBAL FUNCTIONS DEFINED IN THIS MODULE :				*/
/*	NONE								*/
/*									*/
/* MODIFICATION LOG :							*/
/*  Date     Who			Comments			*/
/* --------  ---  ------   -------------------------------------------	*/
/* 08/31/11  JRB	   Fix CLTP encoding.				*/
/* 07/22/11  JRB	   Initial revision				*/
/************************************************************************/
#include "iec_glbtypes.h"
#include "iec_sysincs.h"

#include <sys/types.h>
#include "process.h"
#include "winsock.h"



//#include <ws2tcpip.h>	/* for IP_MULTICAIEC_TTL	*/
#include "iec_90_5.h"



static unsigned char test_IEC_key[] = {
	0x01,0x33,0x34,0x35,0x36,0x37,0x01,0x33,0x34,0x35,0x36,0x37,0x38,0x66,0x77,0x88,
	0x01,0x33,0x34,0x35,0x36,0x37,0x01,0x33,0x34,0x35,0x36,0x37,0x38,0x66,0x77,0x88,
	0x01,0x33,0x34,0x35,0x36,0x37,0x01,0x33,0x34,0x35,0x36,0x37,0x38,0x66,0x77,0x88,
	0x01,0x33,0x34,0x35,0x36,0x37,0x01,0x33,0x34,0x35,0x36,0x37,0x38,0x66,0x77,0x88,
	0x01,0x33,0x34,0x35,0x36,0x37,0x01,0x33,0x34,0x35,0x36,0x37,0x38,0x66,0x77,0x88,
	0x01,0x33,0x34,0x35,0x36,0x37,0x01,0x33,0x34,0x35,0x36,0x37,0x38,0x66,0x77,0x88,
	0x01,0x33,0x34,0x35,0x36,0x37,0x01,0x33,0x34,0x35,0x36,0x37,0x38,0x66,0x77,0x88,
	0x01,0x33,0x34,0x35,0x36,0x37,0x01,0x33,0x34,0x35,0x36,0x37,0x38,0x66,0x77,0x88};


static unsigned char goose_packet[] = {0x61,0x82,0x02,0xf5,0x80,0x0d,
0x6d,0x79,0x64,0x6f,0x6d,0x2f,0x6d,0x79,0x67,0x63,0x52,0x65,0x66,0x81,0x01,0x04,
0x82,0x0f,0x6d,0x79,0x64,0x6f,0x6d,0x2f,0x6d,0x79,0x64,0x61,0x74,0x61,0x73,0x65,
0x74,0x83,0x09,0x74,0x65,0x73,0x74,0x41,0x70,0x70,0x49,0x44,0x84,0x08,0x3f,0xfb,
0x32,0x4c,0x00,0x00,0x00,0x00,0x85,0x01,0x01,0x86,0x01,0x01,0x87,0x01,0x00,0x88,
0x01,0x20,0x89,0x01,0x00,0x8a,0x01,0x03,0xab,0x82,0x02,0xa7,0xa2,0x82,0x02,0x65,
0xa2,0x35,0x85,0x01,0x03,0x87,0x05,0x08,0x40,0x87,0x7c,0xee,0x85,0x01,0x05,0x87,
0x05,0x08,0x40,0xc7,0x7c,0xee,0x85,0x01,0x07,0x87,0x05,0x08,0x41,0x03,0xc2,0x8f,
0x85,0x01,0x09,0x87,0x05,0x08,0x41,0x23,0xc2,0x8f,0x84,0x03,0x00,0x55,0x55,0x8c,
0x06,0x29,0x32,0x2e,0x00,0x17,0x86,0xa2,0x2b,0x85,0x01,0x0f,0x87,0x05,0x08,0x41,
0x81,0xe1,0x48,0x85,0x01,0x11,0x87,0x05,0x08,0x41,0x91,0xe1,0x48,0x85,0x01,0x13,
0x87,0x05,0x08,0x41,0xa1,0xe1,0x48,0x84,0x03,0x00,0x55,0x55,0x8c,0x06,0x29,0x32,
0x2e,0x00,0x17,0x86,0xa2,0x35,0x85,0x01,0x19,0x87,0x05,0x08,0x41,0xd1,0xe1,0x48,
0x85,0x01,0x1b,0x87,0x05,0x08,0x41,0xe1,0xe1,0x48,0x85,0x01,0x1d,0x87,0x05,0x08,
0x41,0xf1,0xe1,0x48,0x85,0x01,0x1f,0x87,0x05,0x08,0x42,0x00,0xef,0x9e,0x84,0x03,
0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,0x17,0x86,0xa2,0x35,0x85,0x01,0x25,
0x87,0x05,0x08,0x42,0x18,0xef,0x9e,0x85,0x01,0x27,0x87,0x05,0x08,0x42,0x20,0xef,
0x9e,0x85,0x01,0x29,0x87,0x05,0x08,0x42,0x28,0xef,0x9e,0x85,0x01,0x2b,0x87,0x05,
0x08,0x42,0x30,0xef,0x9e,0x84,0x03,0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,
0x17,0x86,0xa2,0x17,0x85,0x01,0x31,0x87,0x05,0x08,0x42,0x48,0xef,0x9e,0x84,0x03,
0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,0x17,0x86,0xa2,0x35,0x85,0x01,0x37,
0x87,0x05,0x08,0x42,0x60,0xef,0x9e,0x85,0x01,0x39,0x87,0x05,0x08,0x42,0x68,0xef,
0x9e,0x85,0x01,0x3b,0x87,0x05,0x08,0x42,0x70,0xef,0x9e,0x85,0x01,0x3d,0x87,0x05,
0x08,0x42,0x78,0xef,0x9e,0x84,0x03,0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,
0x17,0x86,0xa2,0x17,0x85,0x01,0x43,0x87,0x05,0x08,0x42,0x88,0x77,0xcf,0x84,0x03,
0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,0x17,0x86,0xa2,0x35,0x85,0x01,0x49,
0x87,0x05,0x08,0x42,0x94,0x77,0xcf,0x85,0x01,0x4b,0x87,0x05,0x08,0x42,0x98,0x77,
0xcf,0x85,0x01,0x4d,0x87,0x05,0x08,0x42,0x9c,0x77,0xcf,0x85,0x01,0x4f,0x87,0x05,
0x08,0x42,0xa0,0x77,0xcf,0x84,0x03,0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,
0x17,0x86,0xa2,0x17,0x85,0x01,0x55,0x87,0x05,0x08,0x42,0xac,0x77,0xcf,0x84,0x03,
0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,0x17,0x86,0xa2,0x35,0x85,0x01,0x5b,
0x87,0x05,0x08,0x42,0xb8,0x77,0xcf,0x85,0x01,0x5d,0x87,0x05,0x08,0x42,0xbc,0x77,
0xcf,0x85,0x01,0x5f,0x87,0x05,0x08,0x42,0xc0,0x77,0xcf,0x85,0x01,0x61,0x87,0x05,
0x08,0x42,0xc4,0x77,0xcf,0x84,0x03,0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,
0x17,0x86,0xa2,0x17,0x85,0x01,0x67,0x87,0x05,0x08,0x42,0xd0,0x78,0x52,0x84,0x03,
0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,0x17,0x86,0xa2,0x35,0x85,0x01,0x6d,
0x87,0x05,0x08,0x42,0xdc,0x78,0x52,0x85,0x01,0x6f,0x87,0x05,0x08,0x42,0xe0,0x78,
0x52,0x85,0x01,0x71,0x87,0x05,0x08,0x42,0xe4,0x78,0x52,0x85,0x01,0x73,0x87,0x05,
0x08,0x42,0xe8,0x78,0x52,0x84,0x03,0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,
0x17,0x86,0xa2,0x17,0x85,0x01,0x79,0x87,0x05,0x08,0x42,0xf4,0x78,0x52,0x84,0x03,
0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,0x17,0x86,0xa2,0x38,0x85,0x01,0x7f,
0x87,0x05,0x08,0x43,0x00,0x3c,0x29,0x85,0x02,0x00,0x81,0x87,0x05,0x08,0x43,0x02,
0x3c,0x29,0x85,0x02,0x00,0x83,0x87,0x05,0x08,0x43,0x04,0x3c,0x29,0x85,0x02,0x00,
0x85,0x87,0x05,0x08,0x43,0x06,0x3c,0x29,0x84,0x03,0x00,0x55,0x55,0x8c,0x06,0x29,
0x32,0x2e,0x00,0x17,0x86,0xa2,0x35,0x85,0x01,0x03,0x87,0x05,0x08,0x40,0x87,0x7c,
0xee,0x85,0x01,0x05,0x87,0x05,0x08,0x40,0xc7,0x7c,0xee,0x85,0x01,0x07,0x87,0x05,
0x08,0x41,0x03,0xc2,0x8f,0x85,0x01,0x09,0x87,0x05,0x08,0x41,0x23,0xc2,0x8f,0x84,
0x03,0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,0x17,0x86,0x87,0x05,0x08,0x40,
0x87,0x7c,0xee
};

static unsigned char goose_tunnel_packet[] = {
0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x61,0x82,0x02,0xf5,0x80,0x0d,
0x6d,0x79,0x64,0x6f,0x6d,0x2f,0x6d,0x79,0x67,0x63,0x52,0x65,0x66,0x81,0x01,0x04,
0x82,0x0f,0x6d,0x79,0x64,0x6f,0x6d,0x2f,0x6d,0x79,0x64,0x61,0x74,0x61,0x73,0x65,
0x74,0x83,0x09,0x74,0x65,0x73,0x74,0x41,0x70,0x70,0x49,0x44,0x84,0x08,0x3f,0xfb,
0x32,0x4c,0x00,0x00,0x00,0x00,0x85,0x01,0x01,0x86,0x01,0x01,0x87,0x01,0x00,0x88,
0x01,0x20,0x89,0x01,0x00,0x8a,0x01,0x03,0xab,0x82,0x02,0xa7,0xa2,0x82,0x02,0x65,
0xa2,0x35,0x85,0x01,0x03,0x87,0x05,0x08,0x40,0x87,0x7c,0xee,0x85,0x01,0x05,0x87,
0x05,0x08,0x40,0xc7,0x7c,0xee,0x85,0x01,0x07,0x87,0x05,0x08,0x41,0x03,0xc2,0x8f,
0x85,0x01,0x09,0x87,0x05,0x08,0x41,0x23,0xc2,0x8f,0x84,0x03,0x00,0x55,0x55,0x8c,
0x06,0x29,0x32,0x2e,0x00,0x17,0x86,0xa2,0x2b,0x85,0x01,0x0f,0x87,0x05,0x08,0x41,
0x81,0xe1,0x48,0x85,0x01,0x11,0x87,0x05,0x08,0x41,0x91,0xe1,0x48,0x85,0x01,0x13,
0x87,0x05,0x08,0x41,0xa1,0xe1,0x48,0x84,0x03,0x00,0x55,0x55,0x8c,0x06,0x29,0x32,
0x2e,0x00,0x17,0x86,0xa2,0x35,0x85,0x01,0x19,0x87,0x05,0x08,0x41,0xd1,0xe1,0x48,
0x85,0x01,0x1b,0x87,0x05,0x08,0x41,0xe1,0xe1,0x48,0x85,0x01,0x1d,0x87,0x05,0x08,
0x41,0xf1,0xe1,0x48,0x85,0x01,0x1f,0x87,0x05,0x08,0x42,0x00,0xef,0x9e,0x84,0x03,
0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,0x17,0x86,0xa2,0x35,0x85,0x01,0x25,
0x87,0x05,0x08,0x42,0x18,0xef,0x9e,0x85,0x01,0x27,0x87,0x05,0x08,0x42,0x20,0xef,
0x9e,0x85,0x01,0x29,0x87,0x05,0x08,0x42,0x28,0xef,0x9e,0x85,0x01,0x2b,0x87,0x05,
0x08,0x42,0x30,0xef,0x9e,0x84,0x03,0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,
0x17,0x86,0xa2,0x17,0x85,0x01,0x31,0x87,0x05,0x08,0x42,0x48,0xef,0x9e,0x84,0x03,
0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,0x17,0x86,0xa2,0x35,0x85,0x01,0x37,
0x87,0x05,0x08,0x42,0x60,0xef,0x9e,0x85,0x01,0x39,0x87,0x05,0x08,0x42,0x68,0xef,
0x9e,0x85,0x01,0x3b,0x87,0x05,0x08,0x42,0x70,0xef,0x9e,0x85,0x01,0x3d,0x87,0x05,
0x08,0x42,0x78,0xef,0x9e,0x84,0x03,0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,
0x17,0x86,0xa2,0x17,0x85,0x01,0x43,0x87,0x05,0x08,0x42,0x88,0x77,0xcf,0x84,0x03,
0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,0x17,0x86,0xa2,0x35,0x85,0x01,0x49,
0x87,0x05,0x08,0x42,0x94,0x77,0xcf,0x85,0x01,0x4b,0x87,0x05,0x08,0x42,0x98,0x77,
0xcf,0x85,0x01,0x4d,0x87,0x05,0x08,0x42,0x9c,0x77,0xcf,0x85,0x01,0x4f,0x87,0x05,
0x08,0x42,0xa0,0x77,0xcf,0x84,0x03,0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,
0x17,0x86,0xa2,0x17,0x85,0x01,0x55,0x87,0x05,0x08,0x42,0xac,0x77,0xcf,0x84,0x03,
0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,0x17,0x86,0xa2,0x35,0x85,0x01,0x5b,
0x87,0x05,0x08,0x42,0xb8,0x77,0xcf,0x85,0x01,0x5d,0x87,0x05,0x08,0x42,0xbc,0x77,
0xcf,0x85,0x01,0x5f,0x87,0x05,0x08,0x42,0xc0,0x77,0xcf,0x85,0x01,0x61,0x87,0x05,
0x08,0x42,0xc4,0x77,0xcf,0x84,0x03,0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,
0x17,0x86,0xa2,0x17,0x85,0x01,0x67,0x87,0x05,0x08,0x42,0xd0,0x78,0x52,0x84,0x03,
0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,0x17,0x86,0xa2,0x35,0x85,0x01,0x6d,
0x87,0x05,0x08,0x42,0xdc,0x78,0x52,0x85,0x01,0x6f,0x87,0x05,0x08,0x42,0xe0,0x78,
0x52,0x85,0x01,0x71,0x87,0x05,0x08,0x42,0xe4,0x78,0x52,0x85,0x01,0x73,0x87,0x05,
0x08,0x42,0xe8,0x78,0x52,0x84,0x03,0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,
0x17,0x86,0xa2,0x17,0x85,0x01,0x79,0x87,0x05,0x08,0x42,0xf4,0x78,0x52,0x84,0x03,
0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,0x17,0x86,0xa2,0x38,0x85,0x01,0x7f,
0x87,0x05,0x08,0x43,0x00,0x3c,0x29,0x85,0x02,0x00,0x81,0x87,0x05,0x08,0x43,0x02,
0x3c,0x29,0x85,0x02,0x00,0x83,0x87,0x05,0x08,0x43,0x04,0x3c,0x29,0x85,0x02,0x00,
0x85,0x87,0x05,0x08,0x43,0x06,0x3c,0x29,0x84,0x03,0x00,0x55,0x55,0x8c,0x06,0x29,
0x32,0x2e,0x00,0x17,0x86,0xa2,0x35,0x85,0x01,0x03,0x87,0x05,0x08,0x40,0x87,0x7c,
0xee,0x85,0x01,0x05,0x87,0x05,0x08,0x40,0xc7,0x7c,0xee,0x85,0x01,0x07,0x87,0x05,
0x08,0x41,0x03,0xc2,0x8f,0x85,0x01,0x09,0x87,0x05,0x08,0x41,0x23,0xc2,0x8f,0x84,
0x03,0x00,0x55,0x55,0x8c,0x06,0x29,0x32,0x2e,0x00,0x17,0x86,0x87,0x05,0x08,0x40,
0x87,0x7c,0xee
};
unsigned char test_IEC_id[]={0x99,0x98,0x97,0x96};


//for unit testing only
extern void repeat_unit_teIEC_key_payloads(int num_repeats);
extern void repeat_unit_teIEC_igmp(int num_repeats, SOCKET rxSocket);

struct sv_thread_info{			  //just used to pass paramters to the demo SV transmit Thread
  KDC_REF *pMyKDCRef;
  char * pInterfaceID;
  IEC_COMM_ADDRESS *pSrcAddress;
  IEC_COMM_ADDRESS *pDestAddress;
  ETHERTYPE_8021Q Val8021Q;
  USHORT IP_TOS_DSCP;
  int *pCancelThreads;
};



/************************************************************************/
/* NOTE: tunnel_pdu_ptr points to GOOSE/SMPVAL PDU starting right AFTER	*/
/*   Ethertype ID. This would be easier if it pointed to the		*/
/*   Ethertype ID, but clnp_snet_read doesn't give us that.		*/
/************************************************************************/
unsigned char *example_tunnel_enc (IEC905_MSG_CNTRL *pMsgCntrl,
	unsigned char *dIEC_mac,		/* DST MAC (must be 6 bytes)	*/
	ST_UINT16 tci,			/* TCI from original message*/
	ST_UINT16 etype_id,	/* Ethertype ID from original message*/
	ST_UCHAR *etype_pdu_ptr,	/* pointer after Ethertype ID	*/
	ST_UINT16 etype_pdu_len,	/* len of PDU after Ethertype ID*/
	ST_UINT *enc_len_ptr)
  {

IEC905_SESS_PDU_HDR_INFO hdr_info;
IEC905_SESS_PAYLOAD_DEF payload_info;
unsigned char *temp_ptr;
unsigned char key_id[4];


/* example of filling in the hearder  */
hdr_info.SessionIdentifer = IEC_90_5_SI_TYPE_TUNNEL;
hdr_info.hmacAlg = HMAC_ALG_SHA_256_128;;
hdr_info.secAlgType = SEC_ALG_NONE	;
hdr_info.key_ptr = pMsgCntrl->currentKey->pKey;;
hdr_info.key_len = pMsgCntrl->currentKey->keyLen;
hdr_info.timeToNextKey= (ST_UINT16)(pMsgCntrl->currentKey-> timeOfexpiration -time(NULL))/60;;
hdr_info.timeOfCurrentKey=(ST_UINT32)pMsgCntrl->nextKey->timeOfInitialUse;;
memcpy(key_id,pMsgCntrl->currentKey->key_id,4);
hdr_info.key_id = key_id;

/* fill in the payload_information  */
payload_info.payload_tag = TUNNEL_PAYLOAD_TYPE_TAG;
payload_info.appID = 0;
payload_info.pdu_len = etype_pdu_len;
payload_info.pdu_ptr = etype_pdu_ptr;
payload_info.etype_id = etype_id;
payload_info.simulationBit = 0x00;
payload_info.etype_id = etype_id;
payload_info.tci = tci;
payload_info.tpid = 0x00;
memcpy(&payload_info.dst_mac,dIEC_mac,6);
payload_info.next = NULL;

  temp_ptr = iec905_sess_enc(&hdr_info,&payload_info,enc_len_ptr);
  return (temp_ptr);
  }


/************************************************************************/
/* NOTE: tunnel_pdu_ptr points to GOOSE/SMPVAL PDU starting right AFTER	*/
/*   Ethertype ID. This would be easier if it pointed to the		*/
/*   Ethertype ID, but clnp_snet_read doesn't give us that.		*/
/************************************************************************/
unsigned char *example_GOOSE_enc (IEC905_MSG_CNTRL *pMsgCntrl,
	ST_UINT16 enc_pdu_len,	
	ST_UCHAR *enc_ptr,
	ST_UINT *enc_len_ptr)
  {

IEC905_SESS_PDU_HDR_INFO hdr_info;
IEC905_SESS_PAYLOAD_DEF payload_info;
unsigned char *temp_ptr;
unsigned char key_id[4];


/* example of filling in the hearder  */
hdr_info.SessionIdentifer = IEC_90_5_SI_TYPE_GOOSE;
hdr_info.hmacAlg = HMAC_ALG_SHA_256_128;;
hdr_info.secAlgType = SEC_ALG_NONE	;
hdr_info.key_ptr = pMsgCntrl->currentKey->pKey;
hdr_info.key_len = pMsgCntrl->currentKey->keyLen;
hdr_info.timeToNextKey= (ST_UINT16)(pMsgCntrl->currentKey-> timeOfexpiration -time(NULL))/60;
hdr_info.timeOfCurrentKey=(ST_UINT32)pMsgCntrl->nextKey->timeOfInitialUse;
memcpy(key_id,pMsgCntrl->currentKey->key_id,4);
hdr_info.key_id = key_id;

/* fill in the payload_information  */
payload_info.payload_tag = GOOSE_PAYLOAD_TYPE_TAG;
payload_info.appID = 0;
payload_info.pdu_len = enc_pdu_len;
payload_info.pdu_ptr = enc_ptr;
payload_info.simulationBit = 0x00;
payload_info.next = NULL;

  temp_ptr = iec905_sess_enc(&hdr_info,&payload_info,enc_len_ptr);
  return (temp_ptr);
  }


/************************************************************************/
/* NOTE: tunnel_pdu_ptr points to GOOSE/SMPVAL PDU starting right AFTER	*/
/*   Ethertype ID. This would be easier if it pointed to the		*/
/*   Ethertype ID, but clnp_snet_read doesn't give us that.		*/
/************************************************************************/
unsigned char *example_SV_enc (IEC905_MSG_CNTRL *pMsgCntrl,
	ST_UINT16 enc_pdu_len,	
	ST_UCHAR *enc_ptr,
	ST_UINT *enc_len_ptr)
  {

IEC905_SESS_PDU_HDR_INFO hdr_info;
IEC905_SESS_PAYLOAD_DEF payload_info;
unsigned char *temp_ptr;
unsigned char key_id[4];


/* example of filling in the hearder  */
hdr_info.SessionIdentifer = IEC_90_5_SI_TYPE_SV;
hdr_info.hmacAlg = HMAC_ALG_SHA_256_128;;
hdr_info.secAlgType = SEC_ALG_NONE	;
hdr_info.key_ptr = pMsgCntrl->currentKey->pKey;
hdr_info.key_len = pMsgCntrl->currentKey->keyLen;
hdr_info.timeToNextKey=  (ST_UINT16)(pMsgCntrl->currentKey-> timeOfexpiration -time(NULL))/60;
hdr_info.timeOfCurrentKey= (ST_UINT32)pMsgCntrl->nextKey->timeOfInitialUse;

memcpy(key_id,pMsgCntrl->currentKey->key_id,4);
hdr_info.key_id = key_id;

/* fill in the payload_information  */
payload_info.payload_tag = SV_PAYLOAD_TYPE_TAG ;
payload_info.appID = 0;
payload_info.pdu_len = enc_pdu_len;
payload_info.pdu_ptr = enc_ptr;
payload_info.simulationBit = 0x00;
payload_info.next = NULL;

  temp_ptr = iec905_sess_enc(&hdr_info,&payload_info,enc_len_ptr);
  return (temp_ptr);
  }


static int SoftwareInitalizationSequence()
{
int retVal;
KDC_CREDENTIALS *pMyLocalCredentials;

    iec905_init_key_storage();				//no error is returned

  //initialize ip socket interface
  if((retVal = iec905_ip_init())!=SUCCESS_IEC905)				
    {
    IEC905_ErrorHandler (retVal, __FILE__, __LINE__);
    return(retVal);
    }
  
  //create a local credential structure
  if((pMyLocalCredentials = iec905_create_kdc_credential())==NULL)
    {
    IEC905_ErrorHandler (FAILURE_IEC905, __FILE__, __LINE__);
    return(FAILURE_IEC905);
    }
		
  //place holder for filling in the actual credentials when that is all worked out

  //now initialize the interface to the KDC with the local credentials

  if((retVal = iec905_init_kdc_interface(pMyLocalCredentials,10))!=SUCCESS_IEC905)
    {
    IEC905_ErrorHandler (retVal, __FILE__, __LINE__);
    return(retVal);
    }
 
  //the local credentials can no be freed since the init function creates an
  //internal copy of the information

   if((retVal=iec905_tx_pdu_init())!=SUCCESS_IEC905)
    {
    IEC905_ErrorHandler (retVal, __FILE__, __LINE__);
    return(retVal);
    }


  return(SUCCESS_IEC905);
}



//sample transmit sequence for Sampled Values in a thread
static void transmit_sequence_sv(void *arg)
{


struct sv_thread_info *pMyThreadInfo = (struct sv_thread_info *)arg;
KDC_REF *pMyKDCRef;
IEC905_MSG_CNTRL *pMyCntrl;
IECSOCKET_TX_INFO *mysockInfo=NULL;
SV_ENC_STRUCT *mySVInfo;
int retVal;
int offset_of_data,i,j;
unsigned char * pRetBuf;
int total_size;
int ret_len;
unsigned char *asdu_data; 


  
  pMyKDCRef = pMyThreadInfo->pMyKDCRef;
//transmit sequence 

  pMyCntrl=iec905_create_msg_cntrl_tx( IEC_KEY_USAGE_TYPE_SV, pMyThreadInfo->pSrcAddress, pMyThreadInfo->pDestAddress, "SISCOExample/MYSVDataSet");

  iec905_kdc_bind(pMyCntrl,pMyKDCRef);

  iec905_get_kdc_tx_keys(pMyCntrl);


  //   open_tx_udp_socket_with_priorities(InterfaceID ,&Val8021Q, &IP_TOS_DSCP, &keyAddress);
  if((retVal=iec905_tx_pdu_open_socket_with_priorities(&mysockInfo,pMyThreadInfo->pInterfaceID ,&pMyThreadInfo->Val8021Q, &pMyThreadInfo->IP_TOS_DSCP, pMyThreadInfo->pDestAddress))!=SUCCESS_IEC905)
      {
    IEC905_ErrorHandler (retVal, __FILE__, __LINE__);
    return;
    }
 

  
  //the sending methodolgy is to encode a packet and then call the transmit function

  //calculate the size of the samples in the ASDU (example shows 10 SV_INT32 values
  total_size = 0;


  for(i = 0;i<10;++i)
  {
    offset_of_data= sv_data_helper_calculate_samples_size_prim (SV_INT32, 0, &ret_len, &total_size);
  }

  mySVInfo= initialize_sv_encode_struct ("ExampleSVID", "SISCOExample/MYSVDataSet", 1,1,0x1,16,1,total_size);

  asdu_data = mySVInfo->asdus[0].pASDU_data;
  offset_of_data= 0;
  j=0;

  while(*(pMyThreadInfo->pCancelThreads) == FALSE)
  {
    offset_of_data = 0;
    for(i=0;i<10;++i)
    { 
      *(ST_UINT32 *)(asdu_data+offset_of_data) = htonl(j);//need to put things in the buffer in network order
      ++j;
      offset_of_data= sv_data_helper_calculate_samples_size_prim (SV_INT32, offset_of_data, &ret_len, &total_size);
    }

    pRetBuf = example_SV_enc (pMyCntrl, mySVInfo->length_to_send,mySVInfo->sv_buffer, &ret_len);

    iec905_tx_pdu (mysockInfo,pMyThreadInfo->pDestAddress, 102,pRetBuf,ret_len);

    free(pRetBuf);
    Sleep(30);
  }

  iec905_tx_pdu_close_socket(mysockInfo);
}


//sample transmit sequence for a GOOSE in a thread
static void transmit_sequence_goose(void *arg)
{
struct sv_thread_info *pMyThreadInfo = (struct sv_thread_info *)arg;
KDC_REF *pMyKDCRef;
IEC905_MSG_CNTRL *pMyCntrl;
IECSOCKET_TX_INFO *mysockInfo=NULL;
int retVal;
int offset_of_data,i,j;
unsigned char * pRetBuf;
int ret_len;


  
  pMyKDCRef = pMyThreadInfo->pMyKDCRef;
//transmit sequence 

  //if NULL is returned that there is a matching control structure that is already in use.  
  //Duplicate Control structures are not allowed
  if((pMyCntrl=iec905_create_msg_cntrl_tx( IEC_KEY_USAGE_TYPE_GOOSE, pMyThreadInfo->pSrcAddress, pMyThreadInfo->pDestAddress, "SISCOExample/MYGOOSEDataSet"))==NULL)
    return;

  //if success is not returned, indicates that the KDC Reference is bad
  if((iec905_kdc_bind(pMyCntrl,pMyKDCRef))!=SUCCESS_IEC905)
    {
    //things that are created, must be destroyed.
    iec905_destroy_msg_cntrl(pMyCntrl);
    return;
    }
    

  //if success is not returned, indicates that keys could not be obtained.
  if((iec905_get_kdc_tx_keys(pMyCntrl))!=SUCCESS_IEC905)
    {
    //things that are created, must be destroyed.
    iec905_destroy_msg_cntrl(pMyCntrl);
    return;
    }


  //   open_tx_udp_socket_with_priorities(InterfaceID ,&Val8021Q, &IP_TOS_DSCP, &keyAddress);
  if((retVal=iec905_tx_pdu_open_socket_with_priorities(&mysockInfo,pMyThreadInfo->pInterfaceID ,&pMyThreadInfo->Val8021Q, &pMyThreadInfo->IP_TOS_DSCP, pMyThreadInfo->pDestAddress))!=SUCCESS_IEC905)
      {
    IEC905_ErrorHandler (retVal, __FILE__, __LINE__);
    //things that are created, must be destroyed.
    iec905_destroy_msg_cntrl(pMyCntrl);
    return;
    }
 

  while(*(pMyThreadInfo->pCancelThreads) == FALSE)
  {

    pRetBuf = example_GOOSE_enc (pMyCntrl, sizeof(goose_packet),goose_packet, &ret_len);

    if(pRetBuf!=NULL)
      {
      iec905_tx_pdu (mysockInfo,pMyThreadInfo->pDestAddress, 102,pRetBuf,ret_len);
      free(pRetBuf);
      }
    else
      {
      //things that are created, must be destroyed.
       iec905_destroy_msg_cntrl(pMyCntrl);
       return;
      }
    Sleep(30);
  }

  iec905_tx_pdu_close_socket(mysockInfo);
}

//sample transmit sequence for a Tunnelled GOOSE in a thread
static void transmit_sequence_tunnelled_goose(void *arg)
{
struct sv_thread_info *pMyThreadInfo = (struct sv_thread_info *)arg;
KDC_REF *pMyKDCRef;
IEC905_MSG_CNTRL *pMyCntrl;
IECSOCKET_TX_INFO *mysockInfo=NULL;
int retVal;
int offset_of_data,i,j;
unsigned char * pRetBuf;
int ret_len;
ST_UCHAR teIEC_mac[6] = {0x01,0x33,0x34,0x35,0x36,0x37};

  
  pMyKDCRef = pMyThreadInfo->pMyKDCRef;
//transmit sequence 

  pMyCntrl=iec905_create_msg_cntrl_tx(IEC_KEY_USAGE_TYPE_TUNNEL, pMyThreadInfo->pSrcAddress, pMyThreadInfo->pDestAddress, "SISCOExample/MYGOOSEDataSet");

  iec905_kdc_bind(pMyCntrl,pMyKDCRef);

  iec905_get_kdc_tx_keys(pMyCntrl);


  //   open_tx_udp_socket_with_priorities(InterfaceID ,&Val8021Q, &IP_TOS_DSCP, &keyAddress);
  if((retVal=iec905_tx_pdu_open_socket_with_priorities(&mysockInfo,pMyThreadInfo->pInterfaceID ,&pMyThreadInfo->Val8021Q, &pMyThreadInfo->IP_TOS_DSCP, pMyThreadInfo->pDestAddress))!=SUCCESS_IEC905)
      {
    IEC905_ErrorHandler (retVal, __FILE__, __LINE__);
    return;
    }
 

  
  //the sending methodolgy is to encode a packet and then call the transmit function

  //calculate the size of the samples in the ASDU (example shows 10 SV_INT32 values


  while(*(pMyThreadInfo->pCancelThreads) == FALSE)
  {

    pRetBuf= example_tunnel_enc(pMyCntrl,teIEC_mac,0x3333,0x88b8,goose_tunnel_packet,sizeof(goose_tunnel_packet),&ret_len);

    iec905_tx_pdu (mysockInfo,pMyThreadInfo->pDestAddress, 102,pRetBuf,ret_len);

    free(pRetBuf);
    Sleep(30);
  }

  iec905_tx_pdu_close_socket(mysockInfo);
}
/************************************************************************/
/*                       main						*/
/************************************************************************/
int main (int argc, char *argv[])
  {


unsigned int ret_len;
ST_UCHAR *ret_buf;
IEC_COMM_ADDRESS *pKeyAddress;
ST_UCHAR ipAddr1[] = {0x10,0x32,0x33,0x01};
ST_UCHAR ipAddr2[] = {0x10,0x32,0x33,0x02};
char *DataSetRef1  = "SISCO_IED/DataSet1";
SOCKET IEC_90_5_rx_socket;
char InterfaceID[100];
ETHERTYPE_8021Q Val8021Q;
USHORT IP_TOS_DSCP=46;
IEC905_MSG_CNTRL *pMyCntrl;
IECSOCKET_TX_INFO *mysockInfo=NULL;
SV_ENC_STRUCT *mySVInfo;

int retVal;
SV_DEC_STRUCT *myDecInfo;
int  total_size, offset_of_data;
unsigned char *asdu_data;
ST_UINT32 i,j,k;

KDC_CREDENTIALS *pKDCCredential1;
KDC_CREDENTIALS *pKDCCredential2;
KDC_REF *pRetKDCRef;
IEC_COMM_ADDRESS kdcAddress;	      //doesn't have anything in it, but is used to show the process

int fromlen, byte_count;
unsigned char buf[1000];
struct sockaddr addr;
unsigned char *pDecodeBuffer;
IEC_90_5_RX *pMyRxCntrl;
struct sv_thread_info mySVThreadInfo;
struct sv_thread_info myGOOSEThreadInfo;
struct sv_thread_info myTunnelledGOOSEThreadInfo;
int cancelThreads=FALSE;

  setbuf (stdout, NULL);    /* do not buffer the output to stdout   */
  setbuf (stderr, NULL);    /* do not buffer the output to stderr   */

 
  strcpy( InterfaceID,"{62202186-02E1-44AA-9491-DF64A73F58C2}");

  pKeyAddress= create_address_structure(IP_V4_ADDRESS_TYPE, "192.168.20.3");
 
  Val8021Q.priority =4;
  Val8021Q.vlanID =4; 

//the following section is the normal set of initialization call

  //initialize key storage before the receive socket so that everything is
  //OK should a packet come in once the receive Socket is set up
  if((retVal = SoftwareInitalizationSequence())!=SUCCESS_IEC905)
    {
      printf("Could not initialize software\n");
      printf(" Error: %s\n",IEC905_XlatErrorCode(retVal));
    }

  //before transmitting, need to ope a transmit socket.  In this case, we need to do
  //something a little special in order to allow priorities to be set in Windows and Linux
  //thus a intervening function has been provided
  //initalize the UDP receive socket (102) for 90-5 and store the results in the passed Socket Pointer

  if((retVal = iec905_rx_init(&IEC_90_5_rx_socket))!=SUCCESS_IEC905)		
    {
    IEC905_ErrorHandler (retVal, __FILE__, __LINE__);
    return(retVal);
    }


//KDC registration process *************************************************************

  pKDCCredential1 = iec905_create_kdc_credential();
  pKDCCredential2 = iec905_create_kdc_credential();

  //this would typically be the spot to fill in the credentials, but have none currently

  //we will use the dummy addressing for the KDC pair
  pRetKDCRef = iec905_create_KDC_pair(NULL, &kdcAddress,pKDCCredential1 ,&kdcAddress,pKDCCredential2);
  
#if 0
//transmit sequence 

   pMyCntrl=iec905_create_msg_cntrl_tx( IEC_KEY_USAGE_TYPE_SV, pKeyAddress, pKeyAddress, "MYDATASET");

  iec905_kdc_bind(pMyCntrl,pRetKDCRef);

  iec905_get_kdc_tx_keys(pMyCntrl);


  //   open_tx_udp_socket_with_priorities(InterfaceID ,&Val8021Q, &IP_TOS_DSCP, &keyAddress);
  if((retVal=iec905_tx_pdu_open_socket_with_priorities(&mysockInfo,InterfaceID ,&Val8021Q, &IP_TOS_DSCP, pKeyAddress))!=SUCCESS_IEC905)
      {
    IEC905_ErrorHandler (retVal, __FILE__, __LINE__);
    return(retVal);
    }
 

  
  //the sending methodolgy is to encode a packet and then call the transmit function

  //calculate the size of the samples in the ASDU (example shows 10 SV_INT32 values
  total_size = 0;


  for(i = 0;i<10;++i)
  {
    offset_of_data= sv_data_helper_calculate_samples_size_prim (SV_INT32, 0, &ret_len, &total_size);
  }

  mySVInfo= initialize_sv_encode_struct ("MYID", "MYDATASET", 1,1,0x1,16,1,total_size);

  asdu_data = mySVInfo->asdus[0].pASDU_data;
  offset_of_data= 0;
  j=0;


    offset_of_data = 0;
    for(i=0;i<10;++i)
    { 
      *(ST_UINT32 *)(asdu_data+offset_of_data) = htonl(j);//need to put things in the buffer in network order
      ++j;
      offset_of_data= sv_data_helper_calculate_samples_size_prim (SV_INT32, offset_of_data, &ret_len, &total_size);
    }

    ret_buf = example_SV_enc (pMyCntrl, mySVInfo->length_to_send,mySVInfo->sv_buffer, &ret_len);

    iec905_tx_pdu (mysockInfo, &pMyCntrl->keyAddress, 102,ret_buf,ret_len);

    free(ret_buf);

#endif 

  //spawn a thread to continously transmit a SV packet
  mySVThreadInfo.pMyKDCRef = pRetKDCRef;
  mySVThreadInfo.pSrcAddress = pKeyAddress;
  mySVThreadInfo.pDestAddress = pKeyAddress;
  mySVThreadInfo.pCancelThreads = &cancelThreads;
  mySVThreadInfo.pInterfaceID = InterfaceID;
  mySVThreadInfo.Val8021Q= Val8021Q;
  mySVThreadInfo.IP_TOS_DSCP=IP_TOS_DSCP;

  _beginthread(transmit_sequence_sv,0, (void *) &mySVThreadInfo);

 //spawn a thread to continously transmit a GOOSE packet
  myGOOSEThreadInfo.pMyKDCRef = pRetKDCRef;
  myGOOSEThreadInfo.pSrcAddress = pKeyAddress;
  myGOOSEThreadInfo.pDestAddress = pKeyAddress;
  myGOOSEThreadInfo.pCancelThreads = &cancelThreads;
  myGOOSEThreadInfo.pInterfaceID = InterfaceID;
  myGOOSEThreadInfo.Val8021Q= Val8021Q;
  myGOOSEThreadInfo.IP_TOS_DSCP=IP_TOS_DSCP;

  _beginthread(transmit_sequence_goose,0, (void *) &myGOOSEThreadInfo);



 //spawn a thread to continously transmit a Tunnelled GOOSE packet
  myTunnelledGOOSEThreadInfo.pMyKDCRef = pRetKDCRef;
  myTunnelledGOOSEThreadInfo.pSrcAddress = pKeyAddress;
  myTunnelledGOOSEThreadInfo.pDestAddress = pKeyAddress;
  myTunnelledGOOSEThreadInfo.pCancelThreads = &cancelThreads;
  myTunnelledGOOSEThreadInfo.pInterfaceID = InterfaceID;
  myTunnelledGOOSEThreadInfo.Val8021Q= Val8021Q;
  myTunnelledGOOSEThreadInfo.IP_TOS_DSCP=IP_TOS_DSCP;

  _beginthread(transmit_sequence_tunnelled_goose,0, (void *) &myTunnelledGOOSEThreadInfo);


  Sleep(200000);
  return(0);

  //get the length of the packet waiting
  fromlen = sizeof(addr);
  byte_count = recvfrom(IEC_90_5_rx_socket,buf, 1000,MSG_PEEK, &addr, &fromlen);
  pDecodeBuffer = malloc(byte_count);
  byte_count = recvfrom(IEC_90_5_rx_socket,pDecodeBuffer, byte_count,0, &addr, &fromlen);
  pMyRxCntrl = calloc(1, sizeof(IEC_90_5_RX));
  pMyRxCntrl->lengh_of_rxd_buffer = byte_count;
  pMyRxCntrl->rxd_buffer = pDecodeBuffer;
  udp_iec_90_5_dec(pMyRxCntrl );
  myDecInfo = sv_decode(pMyRxCntrl->payload->pdu_ptr,pMyRxCntrl->lengh_of_rxd_buffer);
  free(ret_buf);							  //user frees the encoded PDU when the user determines it is no longer needed


  return(0);


 
 #if 0
  //DEBUG: only need this to get network_device for PCAP.
  //DEBUG: calling this seems to link in most of stack. Try to fix that.
  ret = osicfgx ("osicfg.xml", &mvlCfg);	/* Ignore new data in mvlCfg*/
  if (ret)
    {
    printf ("osicfgx error 0x%X", ret);
    return (ret);
    }

  /* initialize gensock2 before calling any of the socket functions	*/
  /* DEBUG: only to start up sockets. delete this and init directly?	*/
  sockCtx = calloc (1, sizeof(GEN_SOCK_CTXT));
  ret = sockStart ("udp_test", sockCtx);
  if (ret != IEC_SUCCESS)
    {
    return (ret);
    }

    /* Spawn the "Subscriber" as a separate thread.	*/
    {
    IEC_THREAD_HANDLE thread1Handle;
    IEC_THREAD_ID thread1Id;
    gs_start_thread (&subscriber_thread, (IEC_THREAD_ARG)NULL, 
		 &thread1Handle, &thread1Id);
    }
    }
  else
    {
    printf ("ERROR reading 'udp_pub.cfg'. Publisher disabled.\n");
    /* No need to spawn thread for Subscriber. Just call as normal funct.*/
    subscriber_thread (NULL);
    }
  if (ret == IEC_SUCCESS)	/* Publisher init successful	*/
    {
    SendingSocket = udp_pub_socket_get ();

    /* Wait for incoming GOOSE messages.	*/

    }

  //DEBUG: if we ever break out of loop, should probably also call sockEnd here too.
#endif

  }


  
